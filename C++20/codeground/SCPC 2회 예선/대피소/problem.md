간선에 가중치가 있는 연결된 무방향 그래프가 주어져 있다. 간선의 가중치는 해당 간선의 길이에 해당한다.
이 그래프의 정점들 중 일부는 대피소로 지정되어 있다. 각각의 정점에서 가장 가까운 대피소를 찾고
그 대피소까지의 거리를 계산하는 프로그램을 작성하라. 스스로 대피소가 되는 정점에 대해서 가장 가까운 대피소는
자기 자신으로 거리는 0이 된다.
 





위의 그림으로 표현한 예제를 보자. 그림에서 원은 정점, 원 안의 수는 정점의 번호, 선분은 간선, 선분 옆의 수는 간선의 가중치이다.
굵게 그린 원들은 대피소들을 표시한다. 정점 1, 2, 4번은 자신이 대피소이므로, 대피소까지의 거리는 모두 0이 된다.
5번 정점에서 가장 가까운 대피소는 1번 정점이고 거기까지 거리는 5이다.
그림에서 화살표가 있는 곡선으로 가장 가까운 길이 표시되어 있다. 마찬가지로, 3번 정점에서 가장 가까운 대피소는 1번 정점이고
거기까지 거리는 1이다.


- 제한시간: 전체 테스트 케이스는 20개 이하이며, 전체 수행 시간은 1초 이내. (Java 2초 이내) 
    제한 시간을 초과하면 제출한 소스코드의 프로그램이 즉시 종료되며,
    그때까지 수행한 결과에서 테스트 케이스를 1개 그룹 이상 통과하였더라도 점수는 0점이 됩니다.
    그러나, 제한 시간을 초과하더라도 테스트 케이스를 1개 그룹 이상 통과하였다면 '부분 점수(0< 점수< 만점)'를 받을 수 있으며,
    이를 위해서는, C / C++ 에서 "printf 함수" 사용할 경우, 프로그램 시작부분에서 "setbuf(stdout, NULL);"를 한번만 사용하십시오.
    C++에서는 "setbuf(stdout, NULL);"와 "printf 함수" 대신 "cout"를 사용하고, Java에서는 "System.out.printIn"을 사용하시면,
    제한 시간을 초과하더라도 '부분 점수'를 받을 수 있습니다.                                     ※ 언어별 기본 제공 소스코드 내용 참고
    만약, 제한 시간을 초과하지 않았는데도 '부분 점수'를 받았다면, 일부 테스트 케이스를 통과하지 못한 경우 입니다.

- 메모리 사용 제한 : heap, global, static 총계 256MB, stack 1MB
- 제출 제한 : 최대 10회 (제출 횟수를 반영하여 순위 결정 → 동점자의 경우 제출 횟수가 적은 사람에게 높은 순위 부여)

메모리 사용 제한
heap, global, static (총계) : 256MB
stack : 1MB
입력
입력 파일에는 여러 테스트 케이스가 포함될 수 있다.
파일의 첫째 줄에 테스트 케이스의 개수를 나타내는 자연수 T
 가 주어지고,
이후 차례로  T
 개의 테스트 케이스가 주어진다. (1≤T≤20
)
각 케이스의 첫 줄에 정점의 수를 나타내는 자연수 N
 ,
간선의 수를 나타내는 자연수 M
 , 그리고 대피소의 수를 나타내는 자연수 K
 가 주어진다.
(1≤N≤100,000,1≤M≤500,000,1≤K≤N)
. 정점은 1부터 N
 까지 번호가 붙어 있다.
다음 M 개의 줄에 간선에 대한 정보가 3개의 자연수로 주어지는데, 첫 두 수는 간선의 양 끝인 정점의 번호이고,
세번째 수는 간선의 가중치이다. 가중치는 1 이상 10,000이하의 자연수이다. 한 쌍의 정점 사이에는 최대 하나의 간선만 존재한다.
다음 줄에 K
 개의 대피소들의 정점 번호가 주어진다.
입력 그래프는 연결되어 있어서 모든 정점에 대해 가장 가까운 대피소는 반드시 존재한다.

- 점수 : 최대 10회 제출하여 취득한 각각의 점수 중에서 최대 점수 (만점 200점)
   주어지는 테스트 케이스 데이터들의 그룹은 아래와 같으며,
   각 그룹의 테스트 케이스를 모두 맞추었을 때 해당되는 부분 점수를 받을 수 있다.
   ㆍ 그룹 1 ( 10 점) : 1≤N≤10,1≤M≤20

   ㆍ 그룹 2 ( 40 점) : 1≤N≤300,1≤M≤1,000

   ㆍ 그룹 3 ( 60 점) : 1≤N≤2,000,1≤M≤5,000

   ㆍ 그룹 4 ( 90 점) : 이 그룹의 테스트 케이스에서는 별도의 제한이 없다.

출력
각 테스트 케이스의 답을 순서대로 표준출력으로 출력하며, 각 테스트 케이스마다 첫 줄에 “Case #C”를 출력하여야 한다.

이때 C
는 케이스의 번호이다. 다음 줄에 N
 개의 거리의 합 을 자연수로 출력한다. 이들은 정점 번호 순서대로,
가장 가까운 대피소까지의 거리를 계산한 것의 합이어야 한다. 그 다음 줄에 N
 개의 정점 번호의 합을 자연수로 출력한다.
이들은 정점 번호 순서대로, 가장 가까운 대피소의 번호를 계산한 것의 합이어야 한다.
한 정점에 대해 가장 가까운 대피소가 2개 이상인 경우는 그들 중 번호가 가장 작은 것을 사용한다.

입출력예
입력
2
3 3 1
3 1 1
2 3 2
1 2 5
1
5 6 3
1 3 1
1 2 2
2 3 3
2 4 5
4 5 6
3 5 4
1 2 4
출력
Case #1
4
3
Case #2
6
9
